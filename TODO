In rough priority order:

Easy ways to make supertypes / subtypes from existing types
  - making supertypes in particular

deserialization with typechecking

type-checking
  - informative errors on failure
  - support type-checking Hash-like objects via [] property access
  - catch and wrap exceptions while getting data to type-check
  - ability to truncate a type to a certain depth as a nicer more general way to do 'type-check this to depth x' rather than the more ad-hoc shallow_type_check stuff

refinements of String, Numeric etc
  - length limits
  - integer ranges
  - enums - sets of allowed values

stop String type-checking as Sequence via its Enumerable implementation (which isn't even a sequence of characters, rather lines)

compute canonicalised intersections

either: consider ditching untagged unions altogether, or,
an optional further lossy canonical form for unions where only structural features of all terms in the union are preserved

remove vestiges of 'tag' as a first-class concept, and make Object accept a ruby class/module directly not a string

better convenience methods for traversing the type graph and getting info about it
